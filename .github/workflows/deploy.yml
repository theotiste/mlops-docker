name: Deploy to ECS

on:
  push:
    branches: [ main ]

concurrency:
  group: ecs-deploy
  cancel-in-progress: true

env:
  AWS_REGION: eu-west-3
  CLUSTER: mlops-cluster
  SERVICE: mlops--service
  # Seuils (peuvent être surchargés en vars/secrets)
  CPU_ALARM: "80"            # % CPU moyen du service
  MEM_ALARM: "80"            # % mémoire moyenne du service
  TG_5XX_THRESHOLD: "5"      # nb 5xx cibles / 5 min
  ELB_5XX_THRESHOLD: "5"     # nb 5xx ELB / 5 min
  LATENCY_P95_SEC: "1.5"     # p95 TargetResponseTime en secondes
  UNHEALTHY_HOSTS: "1"       # hôtes cibles non sains max
  LOG_RETENTION_DAYS: "14"   # rétention CloudWatch Logs

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools (jq)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Déploiement ECS depuis un task-definition.json versionné
      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: task-definition.json
          service: ${{ env.SERVICE }}
          cluster: ${{ env.CLUSTER }}
          wait-for-service-stability: true

      # Découverte ALB/TargetGroup liés au service (si présents)
      - name: Discover ALB/TargetGroup for service
        id: discover
        shell: bash
        run: |
          set -euo pipefail

          # Récupère la définition du service
          SVC_JSON=$(aws ecs describe-services \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}")

          TG_ARN=$(echo "$SVC_JSON" | jq -r '.services[0].loadBalancers[0].targetGroupArn // empty')

          if [[ -z "${TG_ARN}" || "${TG_ARN}" == "null" ]]; then
            echo "tg_arn="
            echo "lb_arn="
            echo "lb_dim="
            echo "tg_dim="
            echo "has_alb=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # LB ARN depuis le TargetGroup
          LB_ARN=$(aws elbv2 describe-target-groups \
            --target-group-arns "$TG_ARN" \
            | jq -r '.TargetGroups[0].LoadBalancerArns[0]')

          # Dimensions CloudWatch attendues (après loadbalancer/ et targetgroup/)
          LB_DIM=$(echo "$LB_ARN" | sed -E 's#^arn:aws:elasticloadbalancing:[^:]+:[0-9]+:loadbalancer/##')
          TG_DIM=$(echo "$TG_ARN" | sed -E 's#^arn:aws:elasticloadbalancing:[^:]+:[0-9]+:targetgroup/##')

          {
            echo "has_alb=true"
            echo "tg_arn=$TG_ARN"
            echo "lb_arn=$LB_ARN"
            echo "lb_dim=$LB_DIM"
            echo "tg_dim=$TG_DIM"
          } >> "$GITHUB_OUTPUT"

      # Rétention des logs (facultatif) : /ecs/<service>
      - name: Enforce CloudWatch Logs retention
        run: |
          set -euo pipefail
          LOG_GROUP="/ecs/${SERVICE}"
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query "logGroups[?logGroupName=='${LOG_GROUP}'] | length(@)" --output text | grep -q '^1$'; then
            aws logs put-retention-policy \
              --log-group-name "$LOG_GROUP" \
              --retention-in-days "${LOG_RETENTION_DAYS}"
            echo "Retention set to ${LOG_RETENTION_DAYS}d for ${LOG_GROUP}"
          else
            echo "Log group ${LOG_GROUP} not found (skipping)."
          fi

      # Création/MàJ des alarmes CloudWatch (ECS + ALB si présent)
      - name: Create/Update CloudWatch alarms
        env:
          SNS_TOPIC_ARN: ${{ secrets.ALARM_SNS_ARN }}   # optionnel
        run: |
          set -euo pipefail

          SERVICE="${SERVICE}"
          CLUSTER="${CLUSTER}"
          REGION="${AWS_REGION}"

          # Wrapper
          A=(aws cloudwatch put-metric-alarm --region "${REGION}")

          # Période et fenêtres communes (5 minutes)
          ARGS_COMMON=(
            --evaluation-periods 1
            --period 300
            --treat-missing-data notBreaching
            --comparison-operator GreaterThanThreshold
            --alarm-description "Auto-created by GitHub Actions (ECS deploy)."
            --actions-enabled
          )

          # --- Alarme CPU ECS (Average) ---
          "${A[@]}" \
            --alarm-name "${SERVICE}-cpu-high" \
            --namespace "AWS/ECS" \
            --metric-name "CPUUtilization" \
            --statistic Average \
            --threshold "${CPU_ALARM}" \
            --dimensions Name=ClusterName,Value="${CLUSTER}" Name=ServiceName,Value="${SERVICE}" \
            "${ARGS_COMMON[@]}" \
            $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )

          # --- Alarme Mémoire ECS (Average) ---
          "${A[@]}" \
            --alarm-name "${SERVICE}-mem-high" \
            --namespace "AWS/ECS" \
            --metric-name "MemoryUtilization" \
            --statistic Average \
            --threshold "${MEM_ALARM}" \
            --dimensions Name=ClusterName,Value="${CLUSTER}" Name=ServiceName,Value="${SERVICE}" \
            "${ARGS_COMMON[@]}" \
            $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )

          # --- Alarme DesiredCount == 0 (optionnelle) ---
          "${A[@]}" \
            --alarm-name "${SERVICE}-desiredcount-zero" \
            --namespace "AWS/ECS" \
            --metric-name "RunningTaskCount" \
            --comparison-operator LessThanThreshold \
            --threshold 1 \
            --statistic Minimum \
            --dimensions Name=ClusterName,Value="${CLUSTER}" Name=ServiceName,Value="${SERVICE}" \
            --evaluation-periods 1 --period 60 \
            --treat-missing-data breaching \
            --alarm-description "No task running for ${SERVICE}" \
            $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )

          # --- Alarme ALB / TargetGroup (si découverts) ---
          if [[ "${{ steps.discover.outputs.has_alb }}" == "true" ]]; then
            LB_DIM='${{ steps.discover.outputs.lb_dim }}'
            TG_DIM='${{ steps.discover.outputs.tg_dim }}'

            # 5xx cibles (sum / 5min)
            "${A[@]}" \
              --alarm-name "${SERVICE}-tg5xx" \
              --namespace "AWS/ApplicationELB" \
              --metric-name "HTTPCode_Target_5XX_Count" \
              --statistic Sum \
              --threshold "${TG_5XX_THRESHOLD}" \
              --dimensions Name=LoadBalancer,Value="${LB_DIM}" Name=TargetGroup,Value="${TG_DIM}" \
              "${ARGS_COMMON[@]}" \
              $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )

            # 5xx ELB (sum / 5min)
            "${A[@]}" \
              --alarm-name "${SERVICE}-elb5xx" \
              --namespace "AWS/ApplicationELB" \
              --metric-name "HTTPCode_ELB_5XX_Count" \
              --statistic Sum \
              --threshold "${ELB_5XX_THRESHOLD}" \
              --dimensions Name=LoadBalancer,Value="${LB_DIM}" \
              "${ARGS_COMMON[@]}" \
              $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )

            # Latence p95 (TargetResponseTime)
            "${A[@]}" \
              --alarm-name "${SERVICE}-latency-p95" \
              --namespace "AWS/ApplicationELB" \
              --metric-name "TargetResponseTime" \
              --extended-statistic p95 \
              --threshold "${LATENCY_P95_SEC}" \
              --dimensions Name=LoadBalancer,Value="${LB_DIM}" Name=TargetGroup,Value="${TG_DIM}" \
              "${ARGS_COMMON[@]}" \
              $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )

            # Cibles non saines (Maximum)
            "${A[@]}" \
              --alarm-name "${SERVICE}-unhealthy-hosts" \
              --namespace "AWS/ApplicationELB" \
              --metric-name "UnHealthyHostCount" \
              --statistic Maximum \
              --threshold "${UNHEALTHY_HOSTS}" \
              --dimensions Name=TargetGroup,Value="${TG_DIM}" Name=LoadBalancer,Value="${LB_DIM}" \
              "${ARGS_COMMON[@]}" \
              $( [[ -n "${SNS_TOPIC_ARN:-}" ]] && echo --alarm-actions "${SNS_TOPIC_ARN}" )
          else
            echo "No ALB/TargetGroup discovered for ${SERVICE} — skipping ALB alarms."
          fi

      # Tableau de bord CloudWatch minimal
      - name: Create/Update CloudWatch dashboard
        run: |
          set -euo pipefail
          DASH="ECS-${SERVICE}"
          aws cloudwatch put-dashboard --dashboard-name "$DASH" --dashboard-body "$(cat <<'JSON'
          {
            "widgets": [
              {
                "type": "metric",
                "width": 12, "height": 6, "x": 0, "y": 0,
                "properties": {
                  "region": "${AWS_REGION}",
                  "title": "ECS CPU / Memory",
                  "metrics": [
                    [ "AWS/ECS", "CPUUtilization", "ClusterName", "${CLUSTER}", "ServiceName", "${SERVICE}", { "stat": "Average" } ],
                    [ ".", "MemoryUtilization", ".", ".", ".", ".", { "stat": "Average", "yAxis": "right" } ]
                  ],
                  "yAxis": { "left": { "label": "CPU %"}, "right": { "label": "Mem %" } },
                  "period": 300,
                  "stacked": false,
                  "view": "timeSeries"
                }
              }
            ]
          }
          JSON
          )"
          echo "Dashboard updated: https://${AWS_REGION}.console.aws.amazon.com/cloudwatch/home?region=${AWS_REGION}#dashboards:name=${DASH}"
